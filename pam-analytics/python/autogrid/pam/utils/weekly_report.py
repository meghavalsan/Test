"""Weekly reporting module.

The :mod:`autogrid.pam.alert` module generated predictions and issues alerts
based on anomalies generated by the :mod:`autogrid.pam.anomaly` module. This
module determines how successful the predictions have been.
"""

# Copyright (c) 2011-2015 AutoGrid Systems
# Author(s): 'Trevor Stephens' <trevor.stephens@auto-grid.com>

import pandas as pd
from datetime import datetime
from pytz import UTC
from .send_email import send_email


def delta_to_str(delta):
    """Convert a pd.Timedelta object to a string."""
    if delta < pd.Timedelta(0):
        return '-' + str(-1 * delta)
    return str(delta)


class PerformanceSummary(object):

    """A container for reporting on PAM performance.

    Parameters
    ----------
    tenant_tz : pytz.timezone
        Timezone of tenant.

    week_end : pd.TimeStamp
        The end-date of the week (UTC).

    alerts : list of dicts
        A list of the JSON-style output of the alert module over time.

    tickets : pd.DataFrame
        The historical ticket data.

    config : dict
        The configuration of the reporting.

    model_id : str
        The ID for the model, used for reporting.
    """

    def __init__(self, tenant_tz, week_end, alerts, tickets, config, model_id):

        self.tenant_tz = tenant_tz
        self.week_end = week_end
        self.alerts = alerts
        self.tickets = tickets
        self.config = config
        self.model_id = model_id

        self.week_begin = self.week_end - pd.Timedelta(7, 'D')
        self._create_alert_df()
        self._create_tables()

    def _create_alert_df(self):

        alert_df = {'feeder_id': [], 'alert_type': [], 'alert_time_utc': [],
                    'model_version': []}
        for alert in self.alerts:
            for col in ['feeder_id', 'alert_type', 'alert_time_utc',
                        'model_version']:
                alert_df[col].append(alert[col])
        alert_df = pd.DataFrame(alert_df)
        alert_df.alert_time_utc = pd.to_datetime(alert_df.alert_time_utc)
        alert_df.alert_time_utc = alert_df.alert_time_utc.dt.tz_localize(UTC)
        alert_df.alert_time_utc = alert_df.alert_time_utc.dt.tz_convert(self.tenant_tz)
        alert_df['period'] = alert_df.alert_time_utc.dt.strftime('%b %Y')
        alert_df['status'] = 'Pending'
        alert_df['ticket_ids'] = '-'
        alert_df['outage_time'] = '-'
        alert_df['warning'] = '-'
        alert_df['this_week'] = False
        alert_df = alert_df[['period', 'feeder_id', 'alert_type', 'model_version',
                             'alert_time_utc', 'status', 'ticket_ids',
                             'outage_time', 'warning', 'this_week']]
        # To avoid type mismatch error for empty alerts dataframe, set dttype
        # for alert_type column.
        alert_df['alert_type'] = alert_df['alert_type'].astype(str)

        for row in alert_df.index:
            feeder_id = alert_df.loc[row, 'feeder_id']
            alert_time = alert_df.loc[row, 'alert_time_utc']
            miss_types = self.config['miss_type_codes']
            miss_min_t = alert_time + pd.Timedelta(self.config['miss_min_hrs'], 'h')
            miss_max_t = alert_time + pd.Timedelta(self.config['miss_max_hrs'], 'h')
            miss_tix = self.tickets.loc[(self.tickets.FDR_NUM == feeder_id) &
                                        (self.tickets.IRPT_TYPE_CODE.isin(miss_types)) &
                                        (self.tickets.POWEROFF >= miss_min_t) &
                                        (self.tickets.POWEROFF <= miss_max_t)]
            win_types = self.config['win_type_codes']
            win_causes = self.config['win_cause_codes']
            win_min_t = alert_time + pd.Timedelta(self.config['win_min_hrs'], 'h')
            win_max_t = alert_time + pd.Timedelta(self.config['win_max_hrs'], 'h')
            win_tix = self.tickets.loc[(self.tickets.FDR_NUM == feeder_id) &
                                       (self.tickets.IRPT_TYPE_CODE.isin(win_types)) &
                                       (self.tickets.IRPT_CAUS_CODE.isin(win_causes)) &
                                       (self.tickets.POWEROFF >= win_min_t) &
                                       (self.tickets.POWEROFF <= win_max_t)]
            if not miss_tix.empty:
                alert_df.loc[row, 'status'] = 'Near Miss'
                ticket_numbers = ', '.join(miss_tix.TRBL_TCKT_NUM.unique().astype(str))
                alert_df.loc[row, 'ticket_ids'] = ticket_numbers
                outage_time = miss_tix.POWEROFF.min().tz_convert(self.tenant_tz)
                alert_df.loc[row, 'outage_time'] = outage_time
                alert_df.loc[row, 'warning'] = delta_to_str(outage_time - alert_time)
            elif not win_tix.empty:
                alert_df.loc[row, 'status'] = 'Win'
                ticket_numbers = ', '.join(win_tix.TRBL_TCKT_NUM.unique().astype(str))
                alert_df.loc[row, 'ticket_ids'] = ticket_numbers
                outage_time = win_tix.POWEROFF.min().tz_convert(self.tenant_tz)
                alert_df.loc[row, 'outage_time'] = outage_time
                alert_df.loc[row, 'warning'] = delta_to_str(outage_time - alert_time)
                if win_tix.POWEROFF.min() > self.week_begin:
                    alert_df.loc[row, 'this_week'] = True
            elif alert_time + pd.Timedelta(self.config['win_max_hrs'], 'h') < self.week_end:
                alert_df.loc[row, 'status'] = 'Loss'

        alert_df = alert_df.sort_values(by='alert_time_utc', ascending=False)
        self.alert_df = alert_df

    def _performance_for_period(self, period_start, period_end, period_name=None):
        period_stats = {}
        win_types = self.config['win_type_codes']
        win_causes = self.config['win_cause_codes']
        win_tix = self.tickets.loc[(self.tickets.IRPT_TYPE_CODE.isin(win_types)) &
                                   (self.tickets.IRPT_CAUS_CODE.isin(win_causes)) &
                                   (self.tickets.POWEROFF >= period_start) &
                                   (self.tickets.POWEROFF < period_end)]
        period_stats['tickets'] = win_tix.DW_TCKT_KEY.nunique()
        for alert_type in ['Red', 'Orange', 'Yellow']:
            alert_sub = self.alert_df.loc[self.alert_df.alert_type == alert_type]
            if period_name is not None:
                alert_sub = alert_sub.loc[alert_sub.period == period_name]
            else:
                alert_sub = alert_sub.loc[(alert_sub.alert_time_utc >= period_start) &
                                          (alert_sub.alert_time_utc < period_end)]
            period_stats[alert_type.lower()] = alert_sub.shape[0]
        for status in ['Win', 'Near Miss', 'Loss', 'Pending']:
            alert_sub = self.alert_df.loc[self.alert_df.status == status]
            if period_name is not None:
                alert_sub = alert_sub.loc[alert_sub.period == period_name]
            else:
                alert_sub = alert_sub.loc[(alert_sub.alert_time_utc >= period_start) &
                                          (alert_sub.alert_time_utc < period_end)]
            period_stats[status.lower().replace(' ', '_')] = alert_sub.shape[0]
        if period_name is None:
            # Get wins from prior weeks
            old_wins = self.alert_df.loc[(self.alert_df.status == 'Win') &
                                         (self.alert_df.alert_time_utc < period_start),
                                         'outage_time'].tolist()
            old_wins = [t for t in old_wins if t > period_start]
            period_stats['old_wins'] = len(old_wins)

        return period_stats

    def _create_tables(self):

        dates = [self.week_begin.tz_convert(self.tenant_tz),
                 (self.week_end - pd.Timedelta('1h')).tz_convert(self.tenant_tz)]
        dates = [d.strftime('%m/%d/%Y') for d in dates]
        dates = ' - '.join(dates)
        this_week = self._performance_for_period(self.week_begin, self.week_end)
        this_week = pd.DataFrame({'Dates': [dates],
                                  'Outages': [this_week['tickets']],
                                  'Red': [this_week['red']],
                                  'Orange': [this_week['orange']],
                                  'Yellow': [this_week['yellow']],
                                  'Wins': [this_week['win']],
                                  'Near Misses': [this_week['near_miss']],
                                  'Misses': [this_week['loss']],
                                  'Pending': [this_week['pending']],
                                  'Wins From Prior Weeks': [this_week['old_wins']]})
        this_week = this_week[['Dates', 'Red', 'Orange', 'Yellow', 'Wins',
                               'Near Misses', 'Misses', 'Pending',
                               'Wins From Prior Weeks']]
        self.this_week = this_week

        new_wins = self.alert_df.loc[(self.alert_df.this_week) &
                                     (self.alert_df.status == 'Win')].copy()
        new_wins = new_wins[['feeder_id', 'alert_type', 'alert_time_utc',
                             'ticket_ids', 'outage_time', 'warning']]
        new_wins.rename(columns={'feeder_id': 'Feeder',
                                 'alert_type': 'Alert Type',
                                 'alert_time_utc': 'Alert Time',
                                 'ticket_ids': 'Ticket ID',
                                 'outage_time': 'Outage Time',
                                 'warning': 'Warning'}, inplace=True)
        # ordering the data frame columns
        new_wins = new_wins[['Feeder', 'Alert Type', 'Alert Time', 'Ticket ID',
                            'Outage Time', 'Warning']]
        self.new_wins = new_wins

        start_time = self.alert_df.alert_time_utc.min()
        if self.alert_df.shape[0] > 0:
            start_time = start_time.tz_convert(self.tenant_tz).date()
            start_time = datetime(start_time.year, start_time.month, 1, 0)
            start_time = pd.Timestamp(start_time, tz=self.tenant_tz)
            start_time = start_time.tz_convert(UTC)

        monthly = {'Month': [],
                   'Outages': [],
                   'Red': [],
                   'Orange': [],
                   'Yellow': [],
                   'Wins': [],
                   'Near Misses': [],
                   'Misses': [],
                   'Pending': []}

        while start_time < self.alert_df.alert_time_utc.max():
            end_time = start_time + pd.Timedelta(40, 'D')
            end_time -= pd.Timedelta(end_time.day - 1, 'D')
            period = start_time.strftime('%b %Y')

            period_stats = self._performance_for_period(start_time, end_time, period)

            monthly['Month'].append(period)
            monthly['Outages'].append(period_stats['tickets'])
            monthly['Red'].append(period_stats['red'])
            monthly['Orange'].append(period_stats['orange'])
            monthly['Yellow'].append(period_stats['yellow'])
            monthly['Wins'].append(period_stats['win'])
            monthly['Near Misses'].append(period_stats['near_miss'])
            monthly['Misses'].append(period_stats['loss'])
            monthly['Pending'].append(period_stats['pending'])

            start_time = end_time

        for col in monthly:
            monthly[col].reverse()
            if col != 'Month':
                monthly[col].append(sum(monthly[col]))
            else:
                monthly[col].append('Total')

        monthly = pd.DataFrame(monthly)
        monthly = monthly[['Month', 'Outages', 'Red', 'Orange', 'Yellow',
                           'Wins', 'Near Misses', 'Misses', 'Pending']]
        monthly['Accuracy'] = 100. * monthly.Wins.astype(float) / (monthly.Wins +
                                                                   monthly.Misses)
        monthly.Accuracy = monthly.Accuracy.fillna(value=0)
        monthly.Accuracy = monthly.Accuracy.map(lambda x: '%.1f%%' % x)
        monthly['Recall'] = 100. * monthly.Wins.astype(float) / monthly.Outages
        monthly.Recall = monthly.Recall.map(lambda x: '%.1f%%' % x)

        monthly.loc[monthly.Outages == 0, 'Accuracy'] = '-'
        monthly.loc[monthly.Outages == 0, 'Recall'] = '-'

        self.monthly = monthly

        all_time = self.alert_df.copy()
        all_time = all_time[['period', 'feeder_id', 'alert_type', 'model_version',
                             'alert_time_utc', 'status', 'ticket_ids',
                             'outage_time', 'warning']]
        all_time.rename(columns={'period': 'Period',
                                 'feeder_id': 'Feeder',
                                 'alert_type': 'Alert Type',
                                 'model_version': 'Model Version',
                                 'alert_time_utc': 'Alert Time',
                                 'status': 'Status',
                                 'ticket_ids': 'Ticket ID',
                                 'outage_time': 'Outage Time',
                                 'warning': 'Warning'}, inplace=True)
        # ordering the data frame columns
        all_time = all_time[['Period', 'Feeder', 'Alert Type', 'Model Version',
                             'Alert Time', 'Status', 'Ticket ID', 'Outage Time',
                             'Warning']]
        self.all_time = all_time

    def to_html(self):

        html = '<center>\n'

        this_week = self.this_week.to_html(index=False, justify='center')
        new_style = 'style="border-collapse:collapse;">\n' \
                    '  <caption>Weekly NextAlert Performance</caption>'
        this_week = this_week.replace('class="dataframe">', new_style)
        this_week = this_week.replace('<th>Red', '<th bgcolor="#F78181">Red')
        this_week = this_week.replace('<th>Orange', '<th bgcolor="#F7BE81">Orange')
        this_week = this_week.replace('<th>Yellow', '<th bgcolor="#F3F781">Yellow')
        this_week = this_week.replace('<th>', '<th bgcolor="#e0e0e0">')

        html += this_week
        html += '\n<BR>\n<BR>\n'

        new_wins = self.new_wins.to_html(index=False, justify='center')
        new_style = 'style="border-collapse:collapse;">\n' \
                    '  <caption>Weekly NextAlert Win Summary</caption>'
        new_wins = new_wins.replace('class="dataframe">', new_style)
        new_wins = new_wins.replace('<td>Red', '<th bgcolor="#F78181">Red')
        new_wins = new_wins.replace('<td>Orange', '<th bgcolor="#F7BE81">Orange')
        new_wins = new_wins.replace('<td>Yellow', '<th bgcolor="#F3F781">Yellow')
        new_wins = new_wins.replace('<th>', '<th bgcolor="#e0e0e0">')

        html += new_wins
        html += '\n<BR>\n<BR>\n'

        monthly = self.monthly.to_html(index=False, justify='center')
        new_style = 'style="border-collapse:collapse;">\n' \
                    '  <caption>Historical NextAlert Performance</caption>'
        monthly = monthly.replace('class="dataframe">', new_style)
        monthly = monthly.replace('<th>Red', '<th bgcolor="#F78181">Red')
        monthly = monthly.replace('<th>Orange', '<th bgcolor="#F7BE81">Orange')
        monthly = monthly.replace('<th>Yellow', '<th bgcolor="#F3F781">Yellow')
        monthly = monthly.replace('<th>', '<th bgcolor="#e0e0e0">')

        html += monthly
        html += '\n<BR>\n<BR>\n'

        all_time = self.all_time.to_html(index=False, justify='center')
        new_style = 'style="border-collapse:collapse;">\n' \
                    '  <caption>Historical NextAlert Alert Summary</caption>'
        all_time = all_time.replace('class="dataframe">', new_style)
        all_time = all_time.replace('<td>Red', '<th bgcolor="#F78181">Red')
        all_time = all_time.replace('<td>Orange', '<th bgcolor="#F7BE81">Orange')
        all_time = all_time.replace('<td>Yellow', '<th bgcolor="#F3F781">Yellow')
        all_time = all_time.replace('<th>', '<th bgcolor="#e0e0e0">')

        html += all_time
        html += '\n<BR>\n<BR>\nPowered by AutoGrid\n'
        html += '</center>'

        html = html.replace('-05:00', ' EST').replace('-04:00', ' EDT')
        html = html.replace('-0500', ' EST').replace('-0400', ' EDT')

        return html

    def get_subject(self):

        return "NextAlert Model v%s Weekly Report: %s" % (self.model_id,
                                                          self.week_end.date())


def send_summary(performance_summary, to_email, from_email,
                 method='sendgrid', api_key=None, server=None, port=None):
    """Create an email for the performance summary.

    Parameters
    ----------
    performance_summary : fitted PerformanceSummary object.
        The summary report generated from the alerts and tickets.

    to_email : list of str
        The email addresses to send the messages to.

    from_email : str
        The email address to send the messages from.

    method : str, optional (default='sendgrid')
        The method by which to send the email. Either 'sendgrid' or 'smarthost'.

    api_key : str or None, optional (default=None)
        The API key for sendgrid service. Only used when `method` is 'sendgrid'.

    server : str or None, optional (default=None)
        The address of the smarthost. Only used when `method` is 'smarthost'.

    port : int or None, optional (default=None)
        The port of the smarthost. Only used when `method` is 'smarthost'.

    Returns
    -------
    results : tuple
        The results of the attempt to email of form (status, msg)
    """
    report_html = performance_summary.to_html()

    subject = performance_summary.get_subject()

    status, msg = send_email(to_email=to_email,
                             from_email=from_email,
                             subject=subject,
                             html=report_html,
                             method=method,
                             api_key=api_key,
                             server=server,
                             port=port)

    return status, msg
