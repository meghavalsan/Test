"""Weekly reporting module.

The :mod:`autogrid.pam.alert` module generated predictions and issues alerts
based on anomalies generated by the :mod:`autogrid.pam.anomaly` module. This
module determines how successful the predictions have been.
"""

# Copyright (c) 2011-2015 AutoGrid Systems
# Author(s): 'Trevor Stephens' <trevor.stephens@auto-grid.com>

import os
import yaml
import datetime
import pandas as pd
import json
import autogrid.foundation.util.RDBMSUtil as rdbmsUtil
from autogrid.foundation.util.Logger import Logger
from autogrid.pam.anomaly import utils
from autogrid.pam.anomaly.global_define import UTC, EASTERN
from autogrid.pam.utils.weekly_report import PerformanceSummary, send_summary


class WeeklyReportGenerator(object):

    """Weekly report generator class.

    Parameters
    ----------
    system : str
        System name - PAM

    tenant_id : int
        unique id of tenant.
    """

    def __init__(self, system, tenant_id):
        # Calculate week_end datetime from configured week_day
        self.__logger = Logger.get_logger(self.__class__.__name__)
        self.rdbms_util = rdbmsUtil.RDBMSUtil()
        self.system = system
        self.tenant_id = tenant_id
        self.tenant_tz = utils.get_timezone(self.system, self.tenant_id)

        foundation_home = os.environ.get('FOUNDATION_HOME')
        if foundation_home is None:
            self.__logger.error("FOUNDATION_HOME is not set in environment")
            raise KeyError('FOUNDATION_HOME')

        settings_path = os.path.join(foundation_home, 'settings.yml')
        settings_dict = yaml.load(open(settings_path, 'r'))[self.system]

        wr_config_path = os.path.join(foundation_home, 'weekly_report.yaml')
        self.wr_config_dict = yaml.load(open(wr_config_path, 'r'))

        weekly_report_day_of_week = settings_dict['weekly_report_day_of_week']
        historical_data_in_mnths = \
            settings_dict['weekly_report_historical_data_in_months']

        self.week_end_day = self.get_last_week_day(weekly_report_day_of_week)
        self.historical_data_start_date = self.week_end_day - \
            datetime.timedelta((historical_data_in_mnths * 365) / 12)

    def get_last_week_day(self, day_of_week):
        """Get last week date for given day of week."""
        # Calculate last week_end day
        week_days = {'monday': 1, 'tuesday': 2, 'wednesday': 3, 'thursday': 4,
                     'friday': 5, 'saturday': 6, 'sunday': 7}
        today = pd.Timestamp.utcnow()
        today = today.tz_convert(EASTERN)
        today_day = today.weekday() + 1
        week_day = week_days[day_of_week.lower()]
        look_back = today_day - week_day
        if look_back < 1:
            look_back += 7
        week_end_day = today - pd.Timedelta(look_back, 'D')
        week_end_day = week_end_day.replace(hour=23, minute=59, second=59)
        week_end_day = week_end_day.tz_convert(UTC)
        return week_end_day

    def get_alerts_data(self, model_version):
        """Get alerts data in json format."""
        self.__logger.debug('Weekly report: Select Alerts data from '
                            'start time = %s and end time = %s'
                            % (self.historical_data_start_date, self.week_end_day))
        qry = "SELECT raw_json FROM alerts WHERE alert_time_utc > %s AND " \
              "alert_time_utc <= %s AND model_version = %s"
        rows = self.rdbms_util.select(self.system, qry, (self.historical_data_start_date,
                                                         self.week_end_day,
                                                         model_version))
        alerts_json = []
        for row in rows:
            alerts_json.append(json.loads(row[0]))

        return alerts_json

    def get_tickets_data(self):
        """Get tickets data as pandas dataframe."""
        self.__logger.debug('Weekly report: Select Tickets data from '
                            'start time = %s and end time = %s'
                            % (self.historical_data_start_date, self.week_end_day))
        # Now query all data which is in window (start_date and end_date) and
        # Evaluate anomalies from it.
        qry_columns = ['cmi', 'dw_ticket_id', 'irpt_cause_code',
                       'irpt_type_code', 'power_off', 'power_restore',
                       'repair_action_description', 'repair_action_type',
                       'support_code', 'trbl_ticket_id', 'feeder_id']

        columns = ', '.join(qry_columns)
        qry = "SELECT " + columns + " FROM tickets WHERE power_off > %s AND " \
              "power_off <= %s"
        rows = self.rdbms_util.select(self.system, qry, (self.historical_data_start_date,
                                                         self.week_end_day))

        self.__logger.debug('Weekly report: Converting all tickets result '
                            'data to dataframe...')
        df = pd.DataFrame(rows, columns=qry_columns)

        df.rename(columns={'cmi': 'CMI',
                           'dw_ticket_id': 'DW_TCKT_KEY',
                           'irpt_cause_code': 'IRPT_CAUS_CODE',
                           'irpt_type_code': 'IRPT_TYPE_CODE',
                           'power_off': 'POWEROFF',
                           'power_restore': 'POWERRESTORE',
                           'repair_action_description': 'RPR_ACTN_DS',
                           'repair_action_type': 'RPR_ACTN_TYPE',
                           'support_code': 'SUPT_CODE',
                           'trbl_ticket_id': 'TRBL_TCKT_NUM',
                           'feeder_id': 'FDR_NUM'}, inplace=True)

        df['POWEROFF'] = pd.to_datetime(df['POWEROFF'])
        df['POWERRESTORE'] = pd.to_datetime(df['POWERRESTORE'])
        df.POWEROFF = df.POWEROFF.dt.tz_localize(UTC)
        df.POWERRESTORE = df.POWERRESTORE.dt.tz_localize(UTC)

        return df

    def run(self, to_email_dict, from_email, method, api_key, server, port):
        """Run weekly report and sends email."""
        self.__logger.debug('Weekly report: Running weekly report for week ending @ %s'
                            % (self.week_end_day))
        for model_version in to_email_dict:
            to_email = to_email_dict[model_version]
            alerts_list = self.get_alerts_data(model_version)
            if len(alerts_list) == 0:
                continue
            tickets_df = self.get_tickets_data()
            ps = PerformanceSummary(tenant_tz=self.tenant_tz,
                                    week_end=self.week_end_day,
                                    alerts=alerts_list,
                                    tickets=tickets_df,
                                    config=self.wr_config_dict,
                                    model_id=model_version)
            self.__logger.debug('Weekly report: Calling send_email method of '
                                'PerformanceSummary...')
            send_summary(performance_summary=ps,
                         to_email=to_email,
                         from_email=from_email,
                         method=method,
                         api_key=api_key,
                         server=server,
                         port=port)
